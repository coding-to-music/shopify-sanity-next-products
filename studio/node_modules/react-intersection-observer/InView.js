"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InView = void 0;
const React = __importStar(require("react"));
const observe_1 = require("./observe");
function isPlainChildren(props) {
    return typeof props.children !== 'function';
}
/**
 ## Render props

 To use the `<InView>` component, you pass it a function. It will be called
 whenever the state changes, with the new value of `inView`. In addition to the
 `inView` prop, children also receive a `ref` that should be set on the
 containing DOM element. This is the element that the IntersectionObserver will
 monitor.

 If you need it, you can also access the
 [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)
 on `entry`, giving you access to all the details about the current intersection
 state.

 ```jsx
 import { InView } from 'react-intersection-observer';

 const Component = () => (
 <InView>
 {({ inView, ref, entry }) => (
      <div ref={ref}>
        <h2>{`Header inside viewport ${inView}.`}</h2>
      </div>
    )}
 </InView>
 );

 export default Component;
 ```

 ## Plain children

 You can pass any element to the `<InView />`, and it will handle creating the
 wrapping DOM element. Add a handler to the `onChange` method, and control the
 state in your own component. Any extra props you add to `<InView>` will be
 passed to the HTML element, allowing you set the `className`, `style`, etc.

 ```jsx
 import { InView } from 'react-intersection-observer';

 const Component = () => (
 <InView as="div" onChange={(inView, entry) => console.log('Inview:', inView)}>
 <h2>Plain children are always rendered. Use onChange to monitor state.</h2>
 </InView>
 );

 export default Component;
 ```
 */
class InView extends React.Component {
    constructor(props) {
        super(props);
        this.node = null;
        this._unobserveCb = null;
        this.handleNode = (node) => {
            if (this.node) {
                // Clear the old observer, before we start observing a new element
                this.unobserve();
                if (!node && !this.props.triggerOnce && !this.props.skip) {
                    // Reset the state if we get a new node, and we aren't ignoring updates
                    this.setState({ inView: !!this.props.initialInView, entry: undefined });
                }
            }
            this.node = node ? node : null;
            this.observeNode();
        };
        this.handleChange = (inView, entry) => {
            if (inView && this.props.triggerOnce) {
                // If `triggerOnce` is true, we should stop observing the element.
                this.unobserve();
            }
            if (!isPlainChildren(this.props)) {
                // Store the current State, so we can pass it to the children in the next render update
                // There's no reason to update the state for plain children, since it's not used in the rendering.
                this.setState({ inView, entry });
            }
            if (this.props.onChange) {
                // If the user is actively listening for onChange, always trigger it
                this.props.onChange(inView, entry);
            }
        };
        this.state = {
            inView: !!props.initialInView,
            entry: undefined,
        };
    }
    componentDidUpdate(prevProps) {
        // If a IntersectionObserver option changed, reinit the observer
        if (prevProps.rootMargin !== this.props.rootMargin ||
            prevProps.root !== this.props.root ||
            prevProps.threshold !== this.props.threshold ||
            prevProps.skip !== this.props.skip ||
            prevProps.trackVisibility !== this.props.trackVisibility ||
            prevProps.delay !== this.props.delay) {
            this.unobserve();
            this.observeNode();
        }
    }
    componentWillUnmount() {
        this.unobserve();
        this.node = null;
    }
    observeNode() {
        if (!this.node || this.props.skip)
            return;
        const { threshold, root, rootMargin, trackVisibility, delay } = this.props;
        this._unobserveCb = (0, observe_1.observe)(this.node, this.handleChange, {
            threshold,
            root,
            rootMargin,
            // @ts-ignore
            trackVisibility,
            // @ts-ignore
            delay,
        });
    }
    unobserve() {
        if (this._unobserveCb) {
            this._unobserveCb();
            this._unobserveCb = null;
        }
    }
    render() {
        if (!isPlainChildren(this.props)) {
            const { inView, entry } = this.state;
            return this.props.children({ inView, entry, ref: this.handleNode });
        }
        const _a = this.props, { children, as, tag, triggerOnce, threshold, root, rootMargin, onChange, skip, trackVisibility, delay, initialInView } = _a, props = __rest(_a, ["children", "as", "tag", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView"]);
        return React.createElement(as || tag || 'div', Object.assign({ ref: this.handleNode }, props), children);
    }
}
exports.InView = InView;
InView.displayName = 'InView';
InView.defaultProps = {
    threshold: 0,
    triggerOnce: false,
    initialInView: false,
};
